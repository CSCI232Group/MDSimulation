<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0064)http://introcs.cs.princeton.edu/java/assignments/collisions.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>
Molecular Dynamics Simulation of Hard Spheres
</title></head>

<body>
<h3>COS 226 Programming Assignment</h3>
<h2>Molecular Dynamics Simulation of Hard Spheres</h2>

<p>
Simulate the motion of N colliding particles according to
the laws of elastic collision using event-driven simulation.
Such simulations are widely used in molecular dynamics (MD)
to understand and predict properties of physical systems at
the particle level.
This includes the motion of molecules in a gas,
the dynamics of chemical reactions, atomic diffusion,
sphere packing, the stability of the rings around Saturn,
the phase transitions of cerium and cesium,
one-dimensional self-gravitating systems, and front propagation.
<!--
These simulations are also popular pedagogical tools  in introductory
physics classes for illustrating the kinetic molecular theory (KMT).
-->
The same techniques apply to other domains that involve physical
modeling of particle systems including computer graphics,
computer games, and robotics.


<!-- <a href = "http://arxiv.org/ftp/physics/papers/0405/0405089.pdf">a good reference</a> -->

</p><p><strong>Hard sphere model.</strong>
The <em>hard sphere model</em> (billiard ball model) is an 
idealized model of the motion of atoms or molecules in a container.
In this assignment, we will focus on the two-dimensional version 
called the <em>hard disc model</em>. The salient properties of this
model are listed below.

</p><ul>
<p></p><li>N particles in motion, confined in the unit box.

<p></p></li><li>Particle <em>i</em> has known
position (<em>rx<sub>i</sub>, ry<sub>i</sub></em>),
velocity (<em>vx<sub>i</sub>, vy<sub>i</sub></em>),
mass <em>m<sub>i</sub></em>, 
and radius <em>σ<sub>i</sub></em>.
<!--  (no Heisenberg uncertainty). -->

<p></p></li><li>Particles interact via elastic collisions with
each other and with the reflecting boundary.

<p></p></li><li>No other forces are exerted. Thus, particles travel
in straight lines at constant speed between collisions.

</li></ul>


This simple model plays a central role in statistical mechanics, a field 
<!-- Kinetic Molecular Theory (KMT) --> 
which relates macroscopic
observables (e.g., temperature, pressure, diffusion constant) to microscopic
dynamics (motion of individual atoms and molecules).
Maxwell and Boltzmann used the model to derive the distribution of speeds of
interacting molecules as a function of temperature;
Einstein used it to explain the Brownian motion of pollen grains immersed in water.


<p><strong>Simulation.</strong>
There are two natural approaches to simulating the system of
particles.
</p><ul>

<p></p><li><em>Time-driven simulation.</em> Discretize time into
quanta of size <em>dt</em>. Update the position of each particle
after every <em>dt</em> units of time and check for overlaps.
If there is an overlap, roll back the clock to the time of
the collision, update the velocities of the colliding particles,
and continue the simulation.
This approach is simple, but it suffers from two significant
drawbacks.
First, we must perform N<sup>2</sup> overlap checks per time quantum.
Second, we may miss collisions if <em>dt</em> is too large and colliding
particles fail to overlap when we are looking.
<!-- or incorrectly predict the sequence of collisions mispredict -->
To ensure a reasonably accurate simulation, we must choose dt
to be very small, and this slows down the simulation.

<p></p></li><li><em>Event-driven simulation.</em>
With event-driven simulation we focus on those times at which
interesting events occur.
In the hard disc model, all particles travel in straight line
trajectories at constant speeds between collisions.
Thus, our main challenge is to determine the ordered sequence of
particle collisions.
We address this challenge by maintaining a <em>priority queue</em> of
future events, ordered by time.
At any given time, the priority queue contains all future
collisions that would occur, assuming each particle
moves in a straight line trajectory forever.
As particles collide and change direction, some of the events
scheduled on the priority queue become "stale" or "invalidated",
and no longer correspond to physical collisions.
We can adopt a lazy strategy, leaving such invalidated collision on the priority
queue, waiting to identify and discard them as they are deleted.
The main event-driven simulation loop works as follows:

<ul>
<p></p><li> Delete the <em>impending event</em>, i.e., the one
with the minimum priority <em>t</em>.

<p></p></li><li> If the event corresponds to an invalidated collision, discard it.
The event is invalid if one of the particles has
participated in a collision since the event was inserted onto the
priority queue.

<p></p></li><li> If the event corresponds to a physical collision between particles 
<em>i</em> and <em>j</em>:
<ul>
<p></p><li> Advance all particles to time <em>t</em> along a straight line trajectory.

<p></p></li><li> Update the velocities of the two colliding particles <em>i</em> and <em>j</em>
according to the laws of elastic collision.

<p></p></li><li> Determine all future collisions that would occur involving
either <em>i</em> or <em>j</em>, assuming all particles move in straight line trajectories
from time <em>t</em> onwards. Insert these events onto the priority queue.
</li></ul>


<p></p></li><li> If the event corresponds to a physical collision between particles <em>i</em>
and a wall, do the analogous thing for particle <em>i</em>.

</li></ul>

<p>
This event-driven approach results in a more robust, accurate, and efficient
simulation than the time-driven one.
</p></li></ul>




<p><strong>Collision prediction.</strong>
In this section we present the formulas that specify if and 
when a particle will collide with the boundary or with another particle,
assuming all particles travel in straight-line trajectories.


</p><ul>
<p></p><li><em>Collision between particle and a wall.</em>
Given the position (<em>rx</em>, <em>ry</em>), velocity
(<em>vx</em>, <em>vy</em>), and radius <em>σ</em> of 
a particle at time <em>t</em>, we wish to determine if and when it
will collide with a vertical or horizontal wall.

<p>
</p><center>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-elastic2.png" alt="Elastic Collision Between Two Particles">
</center>
<p>

Since the coordinates are between 0 and 1, a particle comes into
contact with a horizontal wall at time <em>t</em> + Δt if 
the quantity <em>ry</em> + Δ<em>t</em> <em>vy</em> equals either
σ or (1 - σ). Solving for Δ<em>t</em> yields:

</p><p>
</p><blockquote>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-wall.png" alt="collision with horizontal wall">
</blockquote>
<p>

An analogous equation predicts the time of collision with a vertical wall.


</p><p></p></li><li><em>Collision between two particles.</em>
Given the positions and velocities of two particles <em>i</em> and <em>j</em>
at time <em>t</em>,
we wish to determine if and when they will collide with each other.

<p>
</p><center>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-elastic.png" alt="Elastic Collision Between Two Particles">
</center>
<p>


Let (<em>rx<sub>i</sub>' </em>, <em>ry<sub>i</sub>' </em>) and
(<em>rx<sub>j</sub>' </em>, <em>ry<sub>j</sub>' </em>) denote the positions
of particles <em>i</em> and <em>j</em> at the moment of contact, say
<em>t</em> + Δ<em>t</em>.
When the particles collide, their
centers are separated by a distance of σ = σ<sub>i</sub> + σ<sub>j</sub>.
In other words:

</p><blockquote>
σ<sup>2</sup> &nbsp; = &nbsp;
(<em>rx<sub>i</sub>' - rx<sub>j</sub>' </em>)<sup>2</sup> + (<em>ry<sub>i</sub>' - ry<sub>j</sub>' </em>)<sup>2</sup>
</blockquote>

During the time prior to the collision, the particles move in
straight-line trajectories. Thus,

<blockquote>
<em>rx<sub>i</sub>' = rx<sub>i</sub></em> + Δ<em>t vx<sub>i</sub></em>, &nbsp; <em>ry<sub>i</sub>' = ry<sub>i</sub></em> + Δ<em>t vy<sub>i</sub></em>
<br>
<em>rx<sub>j</sub>' = rx<sub>j</sub></em> + Δ<em>t vx<sub>j</sub></em>, &nbsp; <em>ry<sub>j</sub>' = ry<sub>j</sub></em> + Δ<em>t vy<sub>j</sub></em>
</blockquote>

Substituting these four equations into the previous one, solving the
resulting quadratic equation for Δ<em>t</em>, selecting the
physically relevant root,
and simplifying, we obtain an expression for Δ<em>t</em>
in terms of the known positions, velocities, and radii.

<p>
</p><blockquote>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-particle.png" alt="collision between two particles">
</blockquote>
<p>

</p><p>
</p><blockquote>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-def.png" alt="definition of relevant quantities">
</blockquote>
<p>

<!--
<blockquote><pre>
&Delta;x  = rx2 - rx1,  &Delta;y  = ry2 - ry1
&Delta;vx = vx2 - vx1,  &Delta;vy = vy2 - vy1
&Delta;v&sdot;&Delta;r = &Delta;vx*&Delta;x + &Delta;vy*&Delta;y
&Delta;v&sdot;&Delta;v = (&Delta;vx)<sup>2</sup> + (&Delta;vy)<sup>2</sup>
&Delta;r&sdot;&Delta;r = (&Delta;x)<sup>2</sup> + (&Delta;y)<sup>2</sup>
&sigma; = &sigma;<sub>1</sub> + &sigma;<sub>2</sub>     // distance between i and j at collision
d = (&Delta;v&sdot;&Delta;r)<sup>2</sup> - (&Delta;v&sdot;&Delta;v) * (&Delta;r&sdot;&Delta;r - &sigma;<sup>2</sup>)
t = (-(&Delta;v&sdot;&Delta;r) - Math.sqrt(d)) / (&Delta;v&sdot;&Delta;v)
</pre></blockquote>
-->

If either Δ<em>v</em> ⋅ Δ<em>r</em> ≥ 0
or d &lt; 0, then the quadratic equation has no solution for Δ<em>t</em> &gt; 0;
otherwise we are guaranteed that Δ<em>t</em> ≥ 0.

</p></li></ul>

<p><strong>Collision resolution.</strong>
In this section we present the physical formulas that specify the
behavior of a particle after an elastic collision with a reflecting
boundary or with another particle.
For simplicity, we ignore multi-particle collisions.
There are three equations governing
the elastic collision between a pair of hard discs:
(i) conservation of linear momentum, (ii) conservation of kinetic energy,
and (iii) upon collision, the normal force acts perpendicular to the
surface at the collision point.
Physics-ly inclined students are encouraged to derive the equations
from first principles; the rest of you may keep reading.



</p><ul>
<p></p><li><em>Between particle and wall.</em>
If a particle with velocity (<em>vx</em>, <em>vy</em>)
collides with a wall perpendicular to <em>x</em>-axis, then the
new velocity is (-<em>vx</em>, <em>vy</em>); if it collides with a wall
perpendicular to the <em>y</em>-axis, then the
new velocity is (<em>vx</em>, -<em>vy</em>).

<p></p></li><li><em>Between two particles.</em>
When two hard discs collide, the normal force acts along
the line connecting their centers (assuming no friction or spin).
The impulse (<em>Jx</em>, <em>Jy</em>) due to the normal force in the
<em>x</em> and <em>y</em> directions of a perfectly elastic collision
at the moment of contact is:

<p>
</p><blockquote>
<img src="./Molecular Dynamics Simulation of Hard Spheres_files/collision-impulse.png" alt="impulse due to normal force of elastic collision">
</blockquote>
<p>

and where <em>m<sub>i</sub></em> and <em>m<sub>j</sub></em> are the masses of
particles <em>i</em> and <em>j</em>, and
σ, Δ<em>x</em>, Δ<em>y</em> and Δ <em>v</em> ⋅ Δ<em>r</em>
are defined as above.

<!--
<blockquote><pre>
dx   = rx2 - rx1,  dy  = ry2 - ry1            // delta x, delta y
dvx  = vx2 - vx1,  dvy = vy2 - vy1            // delta vy, delta vy
dist = radius1 + radius2                      // distance between i and j at collision
dvdr = dx*dvx + dy*dvy                        // delta v dot delta r
F  = 2 * m1 * m2 * dvdr / ((m1 + m2) * dist)  // signed magnitude of normal force
Fx = F * dx / dist                            // normal force in x-direction
Fy = F * dy / dist                            // normal force in y-direction
</pre></blockquote>
-->

Once we know the impulse, we can apply
Newton's second law (in momentum form) to compute the velocities immediately after
the collision.

</p><blockquote>
<em>vx<sub>i</sub>' = vx<sub>i</sub> + Jx / m<sub>i</sub>, &nbsp;&nbsp; vx<sub>j</sub>' = vx<sub>j</sub> - Jx / m<sub>j</sub></em>
<br>
<em>vy<sub>i</sub>' = vy<sub>i</sub> + Jy / m<sub>i</sub>, &nbsp;&nbsp; vy<sub>j</sub>' = vy<sub>j</sub> - Jy / m<sub>j</sub></em>
</blockquote>

</li></ul>


<p><strong>Data format.</strong>
Use the following data format.
The first line contains the number of particles N.
Each of the remaining N lines consists of 6 real numbers
(position, velocity, mass, and radius) followed by
three integers (red, green, and blue values of color).
You may assume that all of the position coordinates are
between 0 and 1, and the color values are between 0 and 255.
Also, you may assume that none of the particles intersect
each other or the walls.

</p><blockquote><pre>N                            
rx ry vx vy mass radius r g b
rx ry vx vy mass radius r g b
rx ry vx vy mass radius r g b
rx ry vx vy mass radius r g b
</pre></blockquote>



<p><strong>Your task.</strong>
Write a program <tt>MDSimulation.java</tt> that reads in a set of
particles from standard input and animates their motion according to the
laws of elastic collisions and event-driven simulation.

<br>
</p><hr>
<br>
<font color="green">Perhaps everything below is just for the checklist??</font>

<p><strong>Particle collision simulation in Java.</strong>
There are a number of ways to design a particle collision simulation program
using the physics formulas above.
We will describe one such approach, but you are free to substitute
your own ideas instead.
Our approach involves the following
data types: <tt>MinPQ</tt>, <tt>Particle</tt>, <tt>CollisionSystem</tt>,
and <tt>Event</tt>.

</p><ul>

<p></p><li><em>Priority queue.</em>
A standard priority queue where we can check if the priority queue is empty;
insert an arbitrary element; and delete the minimum element.

<p></p></li><li><em>Particle data type.</em>
Create a data type to represent particles moving in the unit box.
Include private instance variables for the position (in the x and y
directions), velocity (in the x and y directions), mass, and radius.
It should also have the following instance methods
<ul>

<p></p><li><tt>public Particle(...)</tt>:
constructor.

<p></p></li><li><tt>public double collidesX()</tt>:
return the duration of time until the invoking particle collides
with a vertical wall, assuming it follows a straight-line trajectory.
If the particle never collides with a vertical wall, return
a negative number 
<font color="green">(or +infinity = DOUBLE_MAX or NaN???)</font>

<p></p></li><li><tt>public double collidesY()</tt>:
return the duration of time until the invoking particle collides
with a horizontal wall, assuming it follows a straight-line trajectory.
If the particle never collides with a horizontal wall, return
a negative number.

<p></p></li><li><tt>public double collides(Particle b)</tt>:
return the duration of time until the invoking particle collides
with particle b, assuming both follow straight-line trajectories.
If the two particles never collide, return a negative value.

<p></p></li><li><tt>public void bounceX()</tt>: update the invoking particle
to simulate it bouncing off a vertical wall.

<p></p></li><li><tt>public void bounceY()</tt>: update the invoking particle
to simulate it bouncing off a horizontal wall.

<p></p></li><li><tt>public void bounce(Particle b)</tt>: update both particles
to simulate them bouncing off each other.

<p></p></li><li><tt>public int getCollisionCount()</tt>: return the total
number of collisions involving this particle.

</li></ul>

<p></p></li><li><em>Event data type.</em>
Create a data type to represent collision events. There are
four different types of events: a collision with a vertical wall,
a collision with a horizontal wall, a collision between two particles,
and a redraw event. This would be a fine opportunity to experiment
with OOP and polymorphism. We propose the following simpler
(but somewhat less elegant approach).

<ul>

<p></p><li><tt>public Event(double t, Particle a, Particle b)</tt>:
&nbsp; Create a new event representing a collision
between particles <tt>a</tt> and <tt>b</tt> at time t.
If neither <tt>a</tt> nor <tt>b</tt>
is <tt>null</tt>, then it represents a pairwise collision between
<tt>a</tt> and <tt>b</tt>; if both <tt>a</tt> and <tt>b</tt>
are <tt>null</tt>, it represents a redraw event; if only <tt>b</tt> 
is <tt>null</tt>, it represents a collision between <tt>a</tt> and
a vertical wall; if only <tt>a</tt> is <tt>null</tt>, it represents
a collision between <tt>b</tt> and a horizontal wall.

<p></p></li><li><tt>public double getTime()</tt>:&nbsp;
return the time associated with the event.

<p></p></li><li><tt>public Particle getParticle1()</tt>:&nbsp;
return the first particle, possibly <tt>null</tt>.

<p></p></li><li><tt>public Particle getParticle2()</tt>:&nbsp;
return the second particle, possibly <tt>null</tt>.

<p></p></li><li><tt>public int compareTo(Object x)</tt>:&nbsp;
compare the time associated with this event and x.
Return a positive number (greater), negative number (less),
or zero (equal) accordingly.

<p></p></li><li><tt>public boolean wasSuperveningEvent()</tt>:
return <tt>true</tt> if the event has been invalidated 
since creation, and 
<tt>false</tt> if the event has been invalidated.

</li></ul>

<p>
In order to implement <tt>wasSuperveningEvent</tt>, the
event data type should store the collision counts of
two particles at the time the event was created.
The event corresponds to a physical collision if the
current collision counts of the particles are the
same as when the event was created.


</p><p></p></li><li><em>Particle collision system.</em>
The main program containing the event-driven simulation.
Follow the event-driven simulation loop described above, but also
consider collisions with the four walls and redraw events.


</li></ul>



<p><strong>Data sets.</strong>
Some possibilities that we'll supply.

</p><ul>

<p></p><li> One particle in motion.

<p></p></li><li> Two particles in head on collision.

<p></p></li><li> Two particles, one at rest, colliding at an angle.

<p></p></li><li> Some good examples for testing and debugging.

<p></p></li><li> One red particle in motion, N blue particles at rest.

<p></p></li><li> N particles on a lattice with random initial directions
(but same speed) so that the total kinetic energy is consistent with
some fixed temperature T, and total linear momentum = 0.
Have a different data set for different values of T.

<p></p></li><li> Diffusion I: assign N very tiny particles of the same size
near the center of the container with random velocities.

<p></p></li><li> Diffusion II: N blue particles on left, N green particles on right
assigned velocities so that they are thermalized (e.g., leave
partition between them and save positions and velocities after
a while). Watch them mix. Calculate average diffusion rate?

<p></p></li><li> N big particles so there isn't much room to move without
hitting something.

<p></p></li><li> Einstein's explanation of Brownian motion:
1 big red particle in the center, N smaller blue particles.

</li></ul>


<p><strong>Things you could compute.</strong>

</p><ul>
<p></p><li><em>Brownian motion.</em>
In 1827, the botanist Robert Brown observed
the motion of wildflower pollen grains immersed in water
using a microscope.
He observed that the pollen grains were in a random
motion, following what would become known as Brownian motion.
This phenomenon was discussed, but no convincing explanation
was provided until Einstein provided a mathematical one in 1905.
Einstein's explanation: the motion of the pollen grain particles
was caused by millions of tiny molecules colliding with the
larger particles. He gave detailed formulas describing the
behavior of tiny particles suspended in a liquid at
a given temperature.
Einstein's explanation was intended to help justify the
existence of atoms and molecules and could be used to 
estimate the size of the molecules.
Einstein's theory of Brownian motion enables engineers to
compute the diffusion constants of alloys by observing
the motion of individual particles.
Here's a flash demo of
<a href="http://introcs.cs.princeton.edu/java/assignments/brownian.swf">Einstein's explanation of Brownian
motion</a> from
<a href="http://nanoatlas.ifs.hr/brownian_motion.html">here</a>.


<p></p></li><li> <em>Free path and free time.</em>
Free path = distance a particle travels between collisions.
Plot histogram. Mean free path = average free path length over
all particles.
As temperature increases, mean free path increases (holding pressure constant).
Compute <em>free time length</em> = time elapsed before a particle
collides with another particle or wall.

<p></p></li><li><em>Collision frequency.</em>
Number of collisions per second.

<p></p></li><li><em>Root mean-square velocity.</em>
Root mean-square velocity / mean free path = collision frequency.
Root mean square velocity = sqrt(3RT/M) where 
molar gas constant R =  8.314 J / mol K,
T = temperature (e.g., 298.15 K), M = molecular mass
(e.g., 0.0319998 kg for oxygen).

<p></p></li><li><em>Maxwell-Boltzmann distribution.</em>
Distribution of velocity of particles in hard sphere model
obey Maxwell-Boltzmann distribution (assuming system has thermalized
and  particles are sufficiently heavy that we can discount quantum-mechanical
effects). Distribution shape depends on temperature.
Velocity of each component has distribution proportional to
exp(-mv_x^2 / 2kT). Magnitude of velocity in d dimensions 
has distribution proportional to v^(d-1) exp(-mv^2 / 2kT).
Used in statistical mechanics because it is unwieldy to simulate
on the order of 10^23 particles.
Reason: velocity in x, y, and z directions are normal (if
all particles have same mass and radius).
In 2d, Rayleigh instead of Maxwell-Boltzmann.

<p></p></li><li><em>Pressure.</em>
Main thermodynamic property of interest = mean pressure.
Pressure = force per unit area exerted against container by
colliding molecules.
In 2d, pressure = average force per unit length on the wall of
the container.

<p></p></li><li><em>Temperature.</em>
Plot temperature over time (should be constant) = 1/N sum(mv^2) / (d k),
where d = dimension = 2, k = Boltzmann's constant.

<p></p></li><li><em>Diffusion.</em>
Molecules travel very quickly (faster than a speeding jet)
but diffuse slowly because they collide with other molecules,
thereby changing their direction.
Two vessels connected by a pipe containing two different types
of particles. Measure fraction of particles of each type in 
each vessel as a function of time.

<p></p></li><li><em>Time reversibility.</em>
Change all velocities and run system backwards.
Neglecting roundoff error, the system will return to its original
state!


<p></p></li><li> <em>Maxwell's demon.</em>
<a href="http://en.wikipedia.org/wiki/Maxwell&#39;s_demon">Maxwell's demon</a>
is a thought experiment conjured up by
James Clerk Maxwell in 1871 to contradict the second law of thermodynamics.
Vertical wall in middle with molecule size trap door,
N particles on left half and N on right half,
particle can only go through trap door if demon lets it through.
Demon lets through faster than average particles from left to right,
and slower than average particles from right to left.
Can use redistribution of energy to run a heat engine by allowing
heat to flow from left to right.
(Doesn't violate law because demon must interact with the physical
world to observe the molecules. Demon must store information about
which side of the trap door the molecule is on.
Demon eventually runs out of storage space and must begin erasing
previous accumulated information to make room for new information.
This erasing of information
increases the entropy, requiring  kT ln 2 units of work.)


</li></ul>

<p><strong>Cell method.</strong>
Useful optimization: divide region into rectangular cells.
Ensure that particles can only collide with particles in one of
9 adjacent cells in any time quantum. Reduces number of binary collision
events that must be calculated. Downside: must monitor particles 
as they move from cell to cell.


</p><p><strong>Extra credit.</strong>
Handle multi-particle collisions. Such collisions are important when
simulating the break in a game of billiards.







</p><address><small>
This assignment was developed by Ben Tsou and Kevin Wayne.
<br>Copyright © 2004.
</small>
</address>



</body></html>